06/06/21 - 13/06/21: Various tutorials on creating 'first apps' / introduction to UI components 
15/06/21: UI Testing on Android using Espresso, Fragments 
16/06/21: ViewModel and Fragment videos, Android Architecture Components Beginner Video. 
Started trying to write unit tests for app but many issues: 
*Using Fragment > Activity to build UI as Fragment has shorter/easier to control life cycle + works with ViewModel, which we want to be 'UI Manager' in future
*But examples given by android doc for Activity class or if for Fragment, written in Kotlin. Can't work out why FragmentScenario class won't run...
*Written a not v good large instrumental test, but wanted to write small, precise unit test --TODO
20/06/21: Android is written in Java 8 - some backwards compatibility adjustments. Put @RequiresApi annotation in ViewModel first iteration.
Implemented ViewModel, where the data for the UI will be stored so if the activity/fragment is destroyed (eg screen rotation), 
state is preserved. Used simple static list to test with emulator & real device. 
25-29/6/21: Watched YT videos about TDD in Android (Philipp Lackner). Current MainViewModel class only contains getters/setters.
Doesn't need testing atm as no formal business logic. Will move on to implementing stack for user req: provide basic way for user
to repeat same flashcards. 
29/6/21: Resolved Button issue - text appears over two lines and improved spacing.
03/07/21: Need new home screen to take user input. Will need new Activity and to use Intent. 
There is also option to use Android Navigation Library instead of Intent but for now, impl bog standard Intent.
04/7/21: NEW FUNCTION not in original spec (1-2 work units) - added back to home button. Android has built-in finish() function
which destroys activity - no need to use stack for manual undo (unless back is to preserve some state *within* the activity).
05/7/21: Implemented RecyclerView/Adapter (to an extent) but it doesn't work well for MyCards - used for endless scroll function.
Thought it could help 'refresh' cards and could come back to it if want to implement swipe > button for moving to next card. 
Conclusion for now - not appropriate!
6/7/21: Figured out how to pass data input from MainActivity into shared VM -> best practice requires major restructure 
9/7/21: Implemented Single Activity structure using Navigation library (post-2018 Android) whilst retaining MVVM. Major refactoring.
App architecture is much better and we are able to use SafeArgs, which should make life easier later.
Have lost 'back' functionality but Navigation should make this a lot simpler.
TODO - implement tests for DB/Room
10/7/21: Researching difficulties in testing LiveData (LD is 'lazy' so always returns null unless observed?)
Implemented helper class available via Android Open Source - uses observeForever() methods, which can only be deployed on main thread
Test: testUpdateOnInsert() has uncovered undesired behaviour. I defined PK as the id, which is right, but this does not prevent users giving same answer
and creating duplicate entries of the same string in the db but with diff ids. 
Eg if user ignores prompt and uses all 3 input fields to put their occupation 3 times, there would be 3 rows in the db with the same string but diff id.
This could cause issues down the line eg 3 x duplicate flashcard sets in one deck, which is not desired. 
User answer is now also defined as unique in the dao to prevent this. 
NEXT - testing the repository class; testing the VM.
11/7/21: Reimplemented some button features and put more business logic in the VM, but now doesn't survive config changes.
NEXT - investigate. Something to do with the observer/livedata
16/7/21: Past week - on rec from StackOverflow, have impl observer not on getAllX() method but on livedata field variable
using Transformations.switchmap(). When the field var is instantiated, it calls getAllX() method.
There are two observers: 1 in the CardDisplayFragment (flashcard screen), which gets the updated data and puts it into UI containers (views).
1 other in the VM itself - which sets up the deck iterator and a 'current card' so that the Fragment can advance from one card to the next.
Keeping a reference to the current card should help us act on the card object later - eg when I reimplement the REPEAT function.
Now that the VM and observers are correctly set up, the data survives config changes eg screen rotation.
Why is this? Guess: delegated management of state to the VM so that the 'current state' is maintained by the JVM in the form of savedInstanceState Bundle.
TODO - Look up how ViewModels are able to automate (?) savedState so that UI and data link survives config changes...
In other news, I have also refactored 'UserAnswer' class to 'CardEntity' (then simply 'Card') entity class, which makes more sense
in terms of what object needs to be passed from the db up the architectural levels to the UI layer. 'UserAnswer' was meant to be simple
for dev simplicity, but it was too simple to the extent that it was unuseful. (It was just a String and id, which made transformation into a 'deck' of cards
that had an interator far too complex...)
Looked at writing unit tests for VM but unsure whether VM will expand beyond getters and setters. If plan is to expand VM to eg data validation functions
then will write tests. Atm, move onto XML database insertion.
NEXT - how to parse XML file as db that can be queried. 
17/7/21: As per Android dev guide, 1) analyse data. 2) initiate the parser. 
JMDict.xml is too big? Read-only - which is fine, but probably not good practice to have 50MB file stored on app, much of which isn't in use most of the time.
NEXT - How to clean/minimise? If I edit the xml file, I have to share it bc of the licence. 
NEXT - investigate use of dummy dictionary to try and get it to work. There is also option of using a smaller JSON file (open source).
Also, see whether there's perhaps a web API can use instead of JMDict after all...
20/7/21: JSON vs xml investigation. If JSON, what's best way to parse/impl in Android. 
23/7/21: Impl JSON deserialisation using Jackson library. DTOs (pojos), builder helper class and new entity. 
NEXT - write more test code, remove extraneous classes

24/7/21: JSON file large bc white space (heavily formatted)? If remove, how much space gain?
**Q: if there is >1 Jword for a given Engword, how do we decide which one is the best to use?
**Q: if there is >1 Card in the database with the same Engword, could be confusing for it to show to user as just a diff card.

HOW DO WE DECIDE WHICH WORD IS THE BEST WORD TO SHOW THE USER? Eg 'history' 
- Using vers of jmdict file with common words only
- "glosses are ordered with the most common appearing first" (https://www.edrdg.org/jmdict/edict_doc.html)
......Therefore, the earlier the gloss the better the word (eg 1 is better than 3)
- (assumption) if a word only has one sense, the better the word
- (assumption) if a word only has one gloss, the better the word
......SO, if senseOrder/senseCount, and glossOrder/glossCount are all 1/1, then that word is the best choice
....otherwise, prioritise gloss (gloss order most imp), then sense 
....gloss order > sense order, then wb gloss/sense count? 
....if gloss order/sense order is low but g/s count is high, then that word is more likely to be the better choice? see cat - could be tie break?

NEXT - Impl clean user input funs: spellcheck, make case-insensitive, ignore spaces before/after (but not in middle)
NEXT - Leftover things... (make text bigger in UI, remove replies from input field after press back...)
NEXT - Provide way to separate 'decks' (recyclerview) so don't have to manually purge db - use this persistence feature to implement 'cache' for user to go back and repeat decks...
Also make it so that if there's an input that is already in the db, get that back and put it in a new deck...
NEXT - quick and dirty romaji
NEXT (lower priority) - thinking more about OS versions. Try and dl emulator on lower v of Android to test... (not just diff screen sizes)

25/7/21: Testing continues (TDD proper). Difficult words: 'history' -> needing priority ordering
'teacher' and 'cat' - needing to account for additional info inside brackets in eng def of json file
TODO - bit worried about main thread (whether need to have executorservice threads for accessing the json file...
also bit concerned need to explore stackoverflow ans that said 'wouldnt save large json file in raw' - why?? bc should save to db??

30/7/21: DatamuseAPI results on 'chef' - data analysis of JSON dl. Impl DatamuseWordBuilder class for breaking down JSON file (as String) with Jackson.
31/7/21: Broke app trying to implement Retrofit.  Fixed...
Trying to work out threading as traversal of large JSON file v slow...
Another heuristic algo for JMDictEntry could be if no exact match then contains?
Works but is too slow atm 
NEXT - execute the big method on a sep thread with the swirly GUI thing
NEXT - look at how to parse huge JSON file better/most efficient way to store (another Repository?)

1/8/21: There is an issue with parsing the huge JSON file.
1. Try and find another way of getting the Japanese dictionary. 
1.1 We don't need all the entries in the file all of the time (so space wastage).
1.2 We reload/search through the entire file every time there is user entry (with every word - what Big O? O(n)? Literally go through every word...) 
- IDEA: could implement indexing? Store as hash map instead?
1.3 Json file is searched using the main thread (not a bg thread or asynch - attached to fragment)
1.4 Does loading the file from JSON make it harder to impl extra features eg spell-check function (from Datamuse API/JSON file)?
1.5 Related to 1.2 - the file is Japanese to English - we are searching for English gloss within List of Values so even thinking about this
as key:value pairs, there is no quicker way to search...

Idea: new (web-based) API jisho.org/ (empty github: https://github.com/Jisho-org/jisho-notes)
https://jisho.org/forum/54fefc1f6e73340b1f160000-is-there-any-kind-of-search-api
eg: https://jisho.org/api/v1/search/words?keyword=%22rain%22 
"just provide credit to Jisho.org for the API and make sure you adhere to the licenses of the data sources that Jisho uses, listed on http://jisho.org/about"
Potential CORs problem? Might need to run through proxy...


7/8/21: So much work over past week. Just today though: read about Dagger2 DI and implemented. Made use of Clean Architecture Framework to impl 'use cases'
creating another layer between VM and Repo, as VM was becoming like a God Object and contained too much intricate business logic. (I wanted VM to be slimmer).
TODO - Finish writing last use case and refactor VM to use cases instead of coupling with repo. - 8/8/21 Done. 
TODO - Look at Hilt as a simpler implementation of DI in Android. 
TODO - test test test. JMDictDao test. 

8/8/21: JMDictDao test failed which makes me think I need to re-look at whether Room is pre-populating the db properly...
Still TODO - Look at Hilt as a simpler implementation of DI in Android. I spent muchos time getting Dagger 2 to work today but if Hilt can simplify things further...
App is now up and running but I need to re-put the logic back into the VM before using emulator...
^Do this to test, as taking time to work out how to get data to load from callback (if that's even pos...)

9/8/21: Worked on aims & objectives. Added wordnet quotes to report. Added more structure and notes.
Reimpl logic into VM but need to revisit retrofit impl as datamuse API service and callback throws NPE.

11/8: (from paper notes) getsimwords: datamuse api seems to work but possible concurrency issues with call.execute()
getjpwords: doesn't work - possible issues:
+ data hasn't preloaded (impl is via callback)
+ possible concurrency issue
+ poss the specific entry we were testing on doesn't exist in the db

12/8: (from paper notes) impl switchmap Transformations in VM on LiveData (different type of Observer pattern) 

13/8/21: Bit of loading time needs to be given to app at start up in order to 'pre-load' jmdict db -> consider splash screen impl. 
NB: LiveData objs should be stored in VM. Observers of LD usually attached in Activity/Fragment onCreate() method. 
NB: API Level 3 required for VM functions from fragments - why? Current min SDK is 24. 
Log of print statements in strategic places to demo how asynch call to remote db is not returning in time:
"SUGAR SPICE..." - playful print from within ViewModel that prints just before cards are returned. (Ie when process should have been completed)
There is also a print statement placed in datamuseusecase that prints after the search results have been achieved. 

Log:
I/ViewRootImpl@1b96c69[MainActivity]: ViewPostIme pointer 1
V/StudioTransport: Handling agent command 1200 for pid: 14828.
I/System.out: SUGAR SPICE ALL THINGS NICE
    SUGAR SPICE ALL THINGS NICE
I/System.out: SUGAR SPICE ALL THINGS NICE
I/System.out: [DatamuseWord{word='cuisine', score=71291, tags=[n]}, DatamuseWord{word='cook', score=69758, tags=[n, v]}, DatamuseWord{word='baker', score=69008, tags=[n, prop]}]
I/System.out: [DatamuseWord{word='cookery', score=96200, tags=[syn, n]}, DatamuseWord{word='cuisine', score=91727, tags=[syn, n]}, DatamuseWord{word='culinary art', score=74966, tags=[syn, n]}]
V/StudioTransport: Handling agent command 1200 for pid: 14828.
I/System.out: [DatamuseWord{word='skill', score=78550, tags=[syn, n]}, DatamuseWord{word='scientific discipline', score=73791, tags=[syn, n, prop]}, Datamu

Also 13/8/21: Learned how to use Log.class to print out debug statements.
Basic functionally works now but there is some lag -> to be handled via loading screen
Have broken the app while trying to impl 'cleaning' method. Today's log ends:

I/Choreographer: Skipped 1336 frames!  The application may be doing too much work on its main thread.
I/OpenGLRenderer: Davey! duration=22287ms; Flags=0, IntendedVsync=1809623468552571, Vsync=1809645735218347, OldestInputEvent=9223372036854775807, NewestInputEvent=0, HandleInputStart=1809645738097278, AnimationStart=1809645738527278, PerformTraversalsStart=1809645739532048, DrawStart=1809645742046932, SyncQueued=1809645745325624, SyncStart=1809645746849086, IssueDrawCommandsStart=1809645747711048, SwapBuffers=1809645754921509, FrameCompleted=1809645757571047, DequeueBufferDuration=985116, QueueBufferDuration=951115, GpuCompleted=0, 
D/AndroidRuntime: Shutting down VM
E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.example.mycards, PID: 20740
    java.util.ConcurrentModificationException
        at java.util.ArrayList$Itr.next(ArrayList.java:860)
        at com.example.mycards.main.SharedViewModel.stripBlankCards(SharedViewModel.java:106)
        at com.example.mycards.main.SharedViewModel.setUpDeck(SharedViewModel.java:91)
        at com.example.mycards.main.SharedViewModel.access$000(SharedViewModel.java:30)
        at com.example.mycards.main.SharedViewModel$1.onChanged(SharedViewModel.java:45)
        at com.example.mycards.main.SharedViewModel$1.onChanged(SharedViewModel.java:42)
        at androidx.lifecycle.LiveData.considerNotify(LiveData.java:133)
        at androidx.lifecycle.LiveData.dispatchingValue(LiveData.java:151)
        at androidx.lifecycle.LiveData.setValue(LiveData.java:309)
        at androidx.lifecycle.MutableLiveData.setValue(MutableLiveData.java:50)
        at androidx.lifecycle.Transformations$2$1.onChanged(Transformations.java:155)
        at androidx.lifecycle.MediatorLiveData$Source.onChanged(MediatorLiveData.java:152)
        at androidx.lifecycle.LiveData.considerNotify(LiveData.java:133)
        at androidx.lifecycle.LiveData.dispatchingValue(LiveData.java:151)
        at androidx.lifecycle.LiveData.setValue(LiveData.java:309)
        at androidx.lifecycle.LiveData$1.run(LiveData.java:93)
        at android.os.Handler.handleCallback(Handler.java:938)
        at android.os.Handler.dispatchMessage(Handler.java:99)
        at android.os.Looper.loop(Looper.java:246)
        at android.app.ActivityThread.main(ActivityThread.java:8512)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:602)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1139)
I/Process: Sending signal. PID: 20740 SIG: 9

14/8/21: Fixed error from yesterday by moving method into Fragment and removing blank cards at the UI level
Implemented romaji conversion.
Began understanding how to impl ProgressBar - experimenting in offline project, to be added to app. 

15/8/21: Discovered that ProgressBar must not be in the main thread in order for it to show. 
Prob need to decouple some components so the right task on the bg thread, so main can hold the ProgressBar.
HOWEVER, setting the progressBar to visible means it shows until the fragment moves to next - no need to set to invisible? 
Decision to move away from this ProgressBar venture fn as taking too much time + not important. 
Decision to concentrate on other features/report writing. For 16/8: assure self that app still works and move on to next.

16/8/21: Report work today. Refactored Fragment to work on Observer pattern, but this seems to have broken Navigation...
Took Nav instructions out of Observer code and back into onClickView code. Seems to work again...
Changed impl so the input string is now also included in the deck itself.
Issue 1: the pause
Issue 2: ProgressBar showing/not showing
PB should be in CardDisplayFragment. Observer on cardReadiness should trigger whether fields (cards) show
Based on component (screen) state. 
main thread should be 'busy' rendering the progress bar. 
From: https://developer.android.com/guide/navigation/navigation-pass-data
"To pass around custom complex data, store the data elsewhere such as a ViewModel or database and only pass an identifier 
while navigating; then retrieve the data in the new location after navigation has concluded."
ACTION: Read about state. - OK.

17/8/21: Read more about state and threading in Android.
Wrote a couple more tests for new feature (introduction of 'decks')
Design Q: should users be able to have same cards in diff decks? Instinctively I want to say yes. 
SO, if deckSeed is diff, then 'same card' is allowed. TODO - change how we define equality in Card...
ACTION: Refactor and more tests (androidtests and unit tests). Sort out threading first, then the saved state.

18/8/21: Major refactoring to make sure data flow is correct & concurrency managed. 
Sorting Observers, then going back to comm between bg/main threads.
ACTION: After Observers, bg/main thread comms, TESTS, saved state. Report.

19/8/21: Put in observers for two usecases (service will be done last as currently using fake data).
Looking at how to impl Handlers so bg/main thread can communicate robustly.

21/8: There is a memory leak somewhere - need to investigate. Resource: https://stackoverflow.com/questions/56911580/w-system-a-resource-failed-to-call-release
Sorted bg/main thread comms issue using combo of Handler on main and callback that delegates all loading/data transformation to threads.
ACTION: more tests, saved state, write report, test/improve results.

22/8: Observed strange phenomenon where JMDict db would not preload/was slow to load. 
I'd input my strings and received no results because of this... Had to stop and changing nothing, start again - worked second time...
Writing up DB part of report + DB tests. 

30/8: May be some duplication in passing to threads during instantiation of jmdict local db. 
MainActivity passes off from main thread to executor -> repo then also does insertAll on ANOTHER executor... 
Repo does not consistently use executors. 
Test cases: do we need to test UseCaseManager? It calls the methods already tested in each UseCase test class. 
Could test the callback Result/Error/Exception cases, but what we really want to test is the VM's observer code, as the VM is the client that receives the callback?
TODO: precision rate per dataset
NB: BEWARE delete all cards = delete all decks BUT delete all decks != delete all cards
FOR 31/8: ~3mins in. Watching CodingWithMitch for OnClickListener for items in RecyclerView: https://www.youtube.com/watch?v=69C1ljfDvl0&ab_channel=CodingWithMitch
We need to get the specific decks(position) to the viewModel via the View. 

31/8: Resolved Listener issue with CWM (above). 
Interesting exception in an unexpected place. Cannot easily recreate it. TODO - investigate further.

E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.example.mycards, PID: 26248
    java.lang.ArrayIndexOutOfBoundsException: length=10; index=-1
        at java.util.ArrayList.get(ArrayList.java:439)
        at com.example.mycards.data.entities.Deck.createName(Deck.java:59) <-- HERE!!!
        at com.example.mycards.data.entities.Deck.<init>(Deck.java:31)
        at com.example.mycards.usecases.createdeck.CreateDeckUseCase.run(CreateDeckUseCase.java:30)
        at com.example.mycards.usecases.UseCaseManager.createDeck(UseCaseManager.java:184)
        at com.example.mycards.main.SharedViewModel$2.onChanged(SharedViewModel.java:96)
        at com.example.mycards.main.SharedViewModel$2.onChanged(SharedViewModel.java:92)
        at androidx.lifecycle.LiveData.considerNotify(LiveData.java:133)
        at androidx.lifecycle.LiveData.dispatchingValue(LiveData.java:151)
        at androidx.lifecycle.LiveData.setValue(LiveData.java:309)
        at androidx.lifecycle.MutableLiveData.setValue(MutableLiveData.java:50)
        at androidx.lifecycle.Transformations$2$1.onChanged(Transformations.java:155)
        at androidx.lifecycle.MediatorLiveData$Source.onChanged(MediatorLiveData.java:152)
        at androidx.lifecycle.LiveData.considerNotify(LiveData.java:133)
        at androidx.lifecycle.LiveData.dispatchingValue(LiveData.java:151)
        at androidx.lifecycle.LiveData.setValue(LiveData.java:309)
        at androidx.lifecycle.LiveData$1.run(LiveData.java:93)
        at android.os.Handler.handleCallback(Handler.java:938)
        at android.os.Handler.dispatchMessage(Handler.java:99)
        at android.os.Looper.loop(Looper.java:246)
        at android.app.ActivityThread.main(ActivityThread.java:8595)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:602)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1130)
V/StudioTransport: Handling agent command 1200 for pid: 26248.
I/Process: Sending signal. PID: 26248 SIG: 9

Weds 1/9: deleteDeck functionality impl and tested using emulator. Assumption: Deck is completely decoupled from Cards so that deleteDeck != deleteCards and vice versa.
New deleteDecks button in Maintenance.

Thurs 2/9: Tested delete button - def works. Error from 31/8 is replicable - need to follow data flow and uncover bug. Wrote more report (bg: nlp).

Fri 3/9: Bug raised on 31/8 fixed. There is a minor glitch when you search again (screen 'flickers').
May be related to state management/way observers are connected. 

Sat 4/9: TODO - read more about state management
TODO - More report writing  (look through notes, make more coherent; get to the feature section to write? Draw diagrams)
TODO - more unit tests SharedViewModel

Sun 5/9:
Mon 6/9: TODO - if time, investigate 'screen flicker' bug raised on 3/9. 
Tues 7/9:
Weds 8/9:
Thurs 9/9:

Fri 10/9: Last call on getting user testers...

Q: how do language dictionaries prioritise which word to display first?

Q&A

Q: What is the difference between FragmentManager and ViewModel?
A: FM is built-in to the Android Framework and doesn't need dev implementation. 
VM is a 'helper class' that helps manage the <i>lifecycle</i> of UI components and changes the way UI data is managed in an app.
VM encourages good architectural design (data is separated from UI code - good for modularity, simplifies testing). 

Q: Is ViewModel the same as onSaveInstanceState()? - No. 
Both address UI data BUT:
*onSaveInstanceState() is a lifecycle callback. 
**Is designed to save a small amount of transient data, not complex objs eg lists.
**Is called during confis changes and when activity goes into the bg.
*VM fundamentally changes the way UI data is managed in the app. 
**Can delegate loading complex data and also acts as temp storage once data is loaded.
**Do not need to reload or process data kept in a VM during config changes or when activiity goes into the bg.
