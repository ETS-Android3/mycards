06/06/21 - 13/06/21: Various tutorials on creating 'first apps' / introduction to UI components 
15/06/21: UI Testing on Android using Espresso, Fragments 
16/06/21: ViewModel and Fragment videos, Android Architecture Components Beginner Video. 
Started trying to write unit tests for app but many issues: 
*Using Fragment > Activity to build UI as Fragment has shorter/easier to control life cycle + works with ViewModel, which we want to be 'UI Manager' in future
*But examples given by android doc for Activity class or if for Fragment, written in Kotlin. Can't work out why FragmentScenario class won't run...
*Written a not v good large instrumental test, but wanted to write small, precise unit test --TODO
20/06/21: Android is written in Java 8 - some backwards compatibility adjustments. Put @RequiresApi annotation in ViewModel first iteration.
Implemented ViewModel, where the data for the UI will be stored so if the activity/fragment is destroyed (eg screen rotation), 
state is preserved. Used simple static list to test with emulator & real device. 
25-29/6/21: Watched YT videos about TDD in Android (Philipp Lackner). Current MainViewModel class only contains getters/setters.
Doesn't need testing atm as no formal business logic. Will move on to implementing stack for user req: provide basic way for user
to repeat same flashcards. 
29/6/21: Resolved Button issue - text appears over two lines and improved spacing.
03/07/21: Need new home screen to take user input. Will need new Activity and to use Intent. 
There is also option to use Android Navigation Library instead of Intent but for now, impl bog standard Intent.
04/7/21: NEW FUNCTION not in original spec (1-2 work units) - added back to home button. Android has built-in finish() function
which destroys activity - no need to use stack for manual undo (unless back is to preserve some state *within* the activity).
05/7/21: Implemented RecyclerView/Adapter (to an extent) but it doesn't work well for MyCards - used for endless scroll function.
Thought it could help 'refresh' cards and could come back to it if want to implement swipe > button for moving to next card. 
Conclusion for now - not appropriate!
6/7/21: Figured out how to pass data input from MainActivity into shared VM -> best practice requires major restructure 
9/7/21: Implemented Single Activity structure using Navigation library (post-2018 Android) whilst retaining MVVM. Major refactoring.
App architecture is much better and we are able to use SafeArgs, which should make life easier later.
Have lost 'back' functionality but Navigation should make this a lot simpler.
TODO - implement tests for DB/Room
10/7/21: Researching difficulties in testing LiveData (LD is 'lazy' so always returns null unless observed?)
Implemented helper class available via Android Open Source - uses observeForever() methods, which can only be deployed on main thread
Test: testUpdateOnInsert() has uncovered undesired behaviour. I defined PK as the id, which is right, but this does not prevent users giving same answer
and creating duplicate entries of the same string in the db but with diff ids. 
Eg if user ignores prompt and uses all 3 input fields to put their occupation 3 times, there would be 3 rows in the db with the same string but diff id.
This could cause issues down the line eg 3 x duplicate flashcard sets in one deck, which is not desired. 
User answer is now also defined as unique in the dao to prevent this. 
NEXT - testing the repository class; testing the VM.
11/7/21: Reimplemented some button features and put more business logic in the VM, but now doesn't survive config changes.
NEXT - investigate. Something to do with the observer/livedata
16/7/21: Past week - on rec from StackOverflow, have impl observer not on getAllX() method but on livedata field variable
using Transformations.switchmap(). When the field var is instantiated, it calls getAllX() method.
There are two observers: 1 in the CardDisplayFragment (flashcard screen), which gets the updated data and puts it into UI containers (views).
1 other in the VM itself - which sets up the deck iterator and a 'current card' so that the Fragment can advance from one card to the next.
Keeping a reference to the current card should help us act on the card object later - eg when I reimplement the REPEAT function.
Now that the VM and observers are correctly set up, the data survives config changes eg screen rotation.
Why is this? Guess: delegated management of state to the VM so that the 'current state' is maintained by the JVM in the form of savedInstanceState Bundle.
TODO - Look up how ViewModels are able to automate (?) savedState so that UI and data link survives config changes...
In other news, I have also refactored 'UserAnswer' class to 'CardEntity' (then simply 'Card') entity class, which makes more sense
in terms of what object needs to be passed from the db up the architectural levels to the UI layer. 'UserAnswer' was meant to be simple
for dev simplicity, but it was too simple to the extent that it was unuseful. (It was just a String and id, which made transformation into a 'deck' of cards
that had an interator far too complex...)
Looked at writing unit tests for VM but unsure whether VM will expand beyond getters and setters. If plan is to expand VM to eg data validation functions
then will write tests. Atm, move onto XML database insertion.
NEXT - how to parse XML file as db that can be queried. 
17/7/21: As per Android dev guide, 1) analyse data. 2) initiate the parser. 
JMDict.xml is too big? Read-only - which is fine, but probably not good practice to have 50MB file stored on app, much of which isn't in use most of the time.
NEXT - How to clean/minimise? If I edit the xml file, I have to share it bc of the licence. 
NEXT - investigate use of dummy dictionary to try and get it to work. There is also option of using a smaller JSON file (open source).
Also, see whether there's perhaps a web API can use instead of JMDict after all...
20/7/21: JSON vs xml investigation. If JSON, what's best way to parse/impl in Android. 
23/7/21: TODO - write more test code, remove extraneous classes
 




Q&A

Q: What is the difference between FragmentManager and ViewModel?
A: FM is built-in to the Android Framework and doesn't need dev implementation. 
VM is a 'helper class' that helps manage the <i>lifecycle</i> of UI components and changes the way UI data is managed in an app.
VM encourages good architectural design (data is separated from UI code - good for modularity, simplifies testing). 

Q: Is ViewModel the same as onSaveInstanceState()? - No. 
Both address UI data BUT:
*onSaveInstanceState() is a lifecycle callback. 
**Is designed to save a small amount of transient data, not complex objs eg lists.
**Is called during confis changes and when activity goes into the bg.
*VM fundamentally changes the way UI data is managed in the app. 
**Can delegate loading complex data and also acts as temp storage once data is loaded.
**Do not need to reload or process data kept in a VM during config changes or when activiity goes into the bg.
